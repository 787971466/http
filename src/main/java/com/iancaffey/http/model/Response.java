package com.iancaffey.http.model;

import com.iancaffey.http.io.ResponseWriter;
import com.iancaffey.http.util.ResponseCode;

import java.io.*;
import java.nio.charset.Charset;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;

/**
 * Response
 * <p>
 * A compiled form of an HTTP response providing structure to the message, clearly indicating the response code, headers, and body.
 * <p>
 * Responses are mutable and reusable. When written out as a HTTP response, the data is read from the class and written to
 * the response {@code OutputStream}.
 * <p>
 * Static responses can be handled by both {@code Controller} and {@code Router}. However, parameterized responses can only
 * be generated by a {@code Controller}.
 *
 * @author Ian Caffey
 * @since 1.0
 */
public class Response {
    private final ResponseCode code;
    private final Map<String, String> headers;

    /**
     * Constructs a new {@code Response} with a {@code ResponseCode.OK} response code and empty headers.
     *
     * @return a new {@code Response}
     */
    public static Response ok() {
        return Response.of(ResponseCode.OK);
    }

    /**
     * Constructs a new {@code Response} with a {@code ResponseCode.OK} response code, headers,
     * and a body represented by a {@code byte[]}.
     *
     * @param content the response body
     * @return a new {@code Response}
     */
    public static Response ok(byte[] content) {
        return Response.of(ResponseCode.OK, content);
    }

    /**
     * Constructs a new {@code Response} with a {@code ResponseCode.OK} response code, headers,
     * and a body represented by a {@code String}.
     *
     * @param content the response body
     * @return a new {@code Response}
     */
    public static Response ok(String content) {
        return Response.of(ResponseCode.OK, content);
    }

    /**
     * Constructs a new {@code Response} with a {@code ResponseCode.OK} response code, headers,
     * and a body represented by a {@code String} with a given charset.
     *
     * @param content the response body
     * @return a new {@code Response}
     */
    public static Response ok(String content, String charset) throws UnsupportedEncodingException {
        return Response.of(ResponseCode.OK, content, charset);
    }

    /**
     * Constructs a new {@code Response} with a {@code ResponseCode.OK} response code, headers,
     * and a body represented by a {@code String} with a given charset.
     *
     * @param content the response body
     * @return a new {@code Response}
     */
    public static Response ok(String content, Charset charset) {
        return Response.of(ResponseCode.OK, content, charset);
    }

    /**
     * Constructs a new {@code Response} with a {@code ResponseCode.OK} response code, headers,
     * and a body represented by a {@code File}.
     *
     * @param file the response body
     * @return a new {@code Response}
     */
    public static Response ok(File file) throws FileNotFoundException {
        return Response.of(ResponseCode.OK, file);
    }

    /**
     * Constructs a new {@code Response} with a {@code ResponseCode.OK} response code, headers,
     * and a body represented by an {@code InputStream}.
     *
     * @param content the response body
     * @return a new {@code Response}
     */
    public static Response ok(InputStream content) {
        return Response.of(ResponseCode.OK, content);
    }

    /**
     * Constructs a new {@code Response} with a specified response code and empty headers.
     *
     * @param code the response code
     * @return a new {@code Response}
     */
    public static Response of(ResponseCode code) {
        return new Response(code, new HashMap<>());
    }

    /**
     * Constructs a new {@code Response} with a specified response code, headers,
     * and a body represented by a {@code byte[]}.
     *
     * @param code    the response code
     * @param content the response body
     * @return a new {@code Response}
     */
    public static Response of(ResponseCode code, byte[] content) {
        return content == null ? Response.of(code) : new Response(code, new HashMap<>()) {
            @Override
            public void apply(ResponseWriter writer) throws Exception {
                super.apply(writer);
                writer.write(content);
            }
        }.header(ResponseWriter.CONTENT_LENGTH, String.valueOf(content.length));
    }

    /**
     * Constructs a new {@code Response} with a specified response code, headers,
     * and a body represented by an {@code String}.
     *
     * @param code    the response code
     * @param content the response body
     * @return a new {@code Response}
     */
    public static Response of(ResponseCode code, String content) {
        return content == null ? Response.of(code) : Response.of(code, content.getBytes());
    }

    /**
     * Constructs a new {@code Response} with a specified response code, headers,
     * and a body represented by a {@code String} with a given charset.
     *
     * @param code    the response code
     * @param content the response body
     * @return a new {@code Response}
     */
    public static Response of(ResponseCode code, String content, String charset) throws UnsupportedEncodingException {
        return content == null ? Response.of(code) : Response.of(code, content.getBytes(charset));
    }

    /**
     * Constructs a new {@code Response} with a specified response code, headers,
     * and a body represented by a {@code String} with a given charset.
     *
     * @param code    the response code
     * @param content the response body
     * @return a new {@code Response}
     */
    public static Response of(ResponseCode code, String content, Charset charset) {
        return content == null ? Response.of(code) : Response.of(code, content.getBytes(charset));
    }

    /**
     * Constructs a new {@code Response} with a specified response code, headers,
     * and a body represented by a {@code File}.
     *
     * @param code the response code
     * @param file the response body
     * @return a new {@code Response}
     */
    public static Response of(ResponseCode code, File file) throws FileNotFoundException {
        return file == null ? Response.of(code) :
                Response.of(code, new FileInputStream(file)).
                        header(ResponseWriter.CONTENT_LENGTH, String.valueOf(file.length()));
    }

    /**
     * Constructs a new {@code Response} with a specified response code, headers,
     * and a body represented by an {@code InputStream}.
     *
     * @param code    the response code
     * @param content the response body
     * @return a new {@code Response}
     */
    public static Response of(ResponseCode code, InputStream content) {
        return new Response(code, new HashMap<>()) {
            @Override
            public void apply(ResponseWriter writer) throws Exception {
                super.apply(writer);
                if (content == null)
                    return;
                int read;
                while ((read = content.read()) != -1)
                    writer.write(read);
            }
        };
    }

    /**
     * Constructs a new {@code Response} with a specified response code and headers.
     *
     * @param code    the response code
     * @param headers the response headers
     */
    public Response(ResponseCode code, Map<String, String> headers) {
        if (code == null || headers == null)
            throw new IllegalArgumentException();
        this.code = code;
        this.headers = headers;
    }

    /**
     * Updates the value for the header entry at the specified key or creates a new one if it does not exist.
     *
     * @param key   the header entry key
     * @param value the header entry value
     * @return {@code this} for method-chaining
     */
    public Response header(String key, String value) {
        headers.put(key, value);
        return this;
    }

    /**
     * Returns the header entry value at the specified key.
     *
     * @param key the header entry key
     * @return the value at the specified key, or {@code null} if it does not exist
     */
    public String header(String key) {
        return headers.get(key);
    }

    /**
     * Returns a copy of the entire headers map.
     * <p>
     * Original insertion order is maintained through the copy. The copy is mutable.
     *
     * @return a copy of the entire headers map
     */
    public Map<String, String> headers() {
        return new LinkedHashMap<>(headers);
    }

    /**
     * Writes out the response headers and message using the {@code ResponseWriter}.
     *
     * @param writer the response writer
     * @throws Exception indicating an error occured while generating the response
     */
    public void apply(ResponseWriter writer) throws Exception {
        writer.printResponseCode(code);
        for (Map.Entry<String, String> entry : headers.entrySet())
            writer.printHeader(entry.getKey(), entry.getValue());
        writer.endHeader();
    }
}
